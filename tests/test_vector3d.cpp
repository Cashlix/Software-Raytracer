#include <UnitTest++.h>#include "../src/vector3d.h"/** * Prueft ob die i. Komponente des Vektors v * gleich dem Wert x entspricht. * Es wird jeweils der x()/v() und z() getter, * sowie der []operator fuer den Wertevergleich * verwendet. * @param v Zeiger auf den zu pruefenden Vektor * @param i Getestet wird bei i==0: x, i==1: y  * und bei i==2: z * @param x Wert der erwartet wird */void vcheck(Vector3D *v, int i, const VTYPE &x){	CHECK(IS_EQUAL((i==0?v->x():i==1?v->y():v->z()), x));	CHECK(IS_EQUAL((*v)[i], x));}SUITE(Vector3D){	TEST(ComparisonMacros)	{		VTYPE value = 0.00f;		CHECK(IS_ZERO(value));		value = 0.001;		CHECK(IS_GREATER_ZERO(value));				// Vergleich mit Epsilon		value = 5.0f;		VTYPE v2 = 5.0f;		CHECK(IS_EQUAL(value, v2));				// SMALLER/GREATER Makros		v2 = 5.000000001f;		CHECK(IS_EQUAL(value, v2));		CHECK(!IS_SMALLER(value, v2));		CHECK(!IS_GREATER(value, v2));		CHECK(!IS_ZERO(v2));		v2 = 5.1f;		CHECK(IS_SMALLER(value, v2));		CHECK(!IS_GREATER(value, v2));		v2 = 4.9f;		CHECK(!IS_SMALLER(value, v2));		CHECK(IS_GREATER(value, v2));		// MIN/MAX Makros		CHECK(IS_SMALLER(MIN(value, v2), MAX(value, v2)));	}	TEST(GetterAndSetter)	{		// Erwarte 0 Initialisierung		Vector3D v;		vcheck(&v, 0, 0);		vcheck(&v, 1, 0);		vcheck(&v, 2, 0);		// Setter Methoden		VTYPE x = 12.345f, y = -0.122f, z = 8;		v.setX(x); v.setY(y); v.setZ(z);		vcheck(&v, 0, x);		vcheck(&v, 1, y);		vcheck(&v, 2, z);				// Mod Methoden		Vector3D a;		v.modX(12); v.modY(13); v.modZ(14);		vcheck(&v, 0, 12);		vcheck(&v, 1, 13);		vcheck(&v, 2, 14);		a = v.modX(x).modY(y).modZ(z);		CHECK(a == v);		vcheck(&a, 0, x);		vcheck(&a, 1, y);		vcheck(&a, 2, z);		// xyz() Methode		VTYPE *f = v.xyz();		CHECK(IS_EQUAL(*f, v.x()));		CHECK(IS_EQUAL(*(f+1), v.y()));		CHECK(IS_EQUAL(*(f+2), v.z()));	}	TEST(Modifier)	{		// +/+= und -/-= Operatoren		VTYPE x = 12.345f, y = -0.122f, z = 8;		Vector3D v(x, y, z);		v += Vector3D(1, 2, 3);		CHECK(v == Vector3D(x+1, y+2, z+3));		v -= Vector3D(1, 2, 3);		CHECK(v == Vector3D(x, y, z));		// */+= Operator		VTYPE f = -2.34f;		v *= f;		CHECK(v == Vector3D(x*f, y*f, z*f));		// Skalarprodukt		Vector3D v2(2, 3, 4);		v = 1/f * v;		VTYPE dot = v * v2;		CHECK(dot == (2*x + 3*y + 4*z));	}	TEST(Normalization)	{		VTYPE x = 12.345f, y = -0.122f, z = 8;		Vector3D v;		CHECK(IS_EQUAL(v.length(), 0));				// Laenge muss 1 sein		VTYPE length = sqrt(x*x + y*y + z*z);		v = Vector3D(x, y, z);		v = v.normalize();		CHECK(IS_EQUAL(v.length(), 1));			// Einzelne Vertices pruefen		vcheck(&v, 0, x*(1/length));		vcheck(&v, 1, y*(1/length));		vcheck(&v, 2, z*(1/length));	}	TEST(VectorGeneration)	{		VTYPE x = 12.345f, y = -0.122f, z = 8;		VTYPE x2 = 245.234501f, y2 = 20.f, z2 = -2.002f;		Vector3D v1(x, y, z);		Vector3D v2(x2, y2, z2);		Vector3D v = v1.vectorTo(v2);		vcheck(&v, 0, x2-x);		vcheck(&v, 1, y2-y);		vcheck(&v, 2, z2-z);	}	TEST(CrossProduct)	{		VTYPE x = 12.345f, y = -0.122f, z = 8;		VTYPE x2 = 245.234501f, y2 = 20.f, z2 = -2.002f;		Vector3D v1(x, y, z);		Vector3D v2(x2, y2, z2);		Vector3D v = v1.crossProduct(v2);		vcheck(&v, 0, y*z2-z*y2);		vcheck(&v, 1, z*x2-x*z2);		vcheck(&v, 2, x*y2-y*x2);	}}