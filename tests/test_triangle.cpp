#include <UnitTest++.h>#include "../src/triangle.h"#include <iostream>using std::cout;SUITE(Triangle){	struct SomeFixture	{		Triangle* t;		Vector3D *A, *B, *C;		SomeFixture() {			A = new Vector3D(0,0,-10);			B = new Vector3D(0,4,-10);			C = new Vector3D(10,0,-10);			t = new Triangle(*A, *B, *C);		}		~SomeFixture() { 			delete t;			delete A;			delete B;			delete C;		}	};	TEST_FIXTURE(SomeFixture, GetterAndSetter)	{		CHECK(t->A() == *A);		CHECK(t->B() == *B);		CHECK(t->C() == *C);				Vector3D newA(1,2,3);		t->setA(newA);		CHECK(t->A() == newA);	}	TEST_FIXTURE(SomeFixture, Test2)	{		//int temp = testData;		//cout << "B: " << temp << "\n";	}	TEST(GetterAndSetter)	{		// A()/B()/C() Getter		Vector3D empty;		Triangle d;		CHECK(d.A() == empty);		CHECK(d.B() == empty);		CHECK(d.C() == empty);		// []operator		Vector3D a(0,1,2), b(3,4,5), c(6,7,8);		d[0] = a; d[1] = b; d[2] = c;		CHECK(d[0] == a);		CHECK(d[1] == b);		CHECK(d[2] == c);		// Setter		d.setA(b);		d.setB(c);		d.setC(a);		CHECK(d[0] == b);		CHECK(d[1] == c);		CHECK(d[2] == a);		// Konstruktor mit Parametern		Triangle d2(a, b, c);		CHECK(d2[0] == a);		CHECK(d2[1] == b);		CHECK(d2[2] == c);	}	TEST(EqualOperator)	{		Triangle t1(0, 2, 6);		Triangle t2(0.00f, 2.000000001f, 6);		CHECK(t1 == t2);	}	TEST(RTTI)	{		Triangle d;		CHECK(d.isTriangle());	}	TEST(Translation)	{		Vector3D a(0,1,2), b(3,4,5), c(6,7,8);		Triangle d(a, b, c);		Vector3D t(5.23f, -0.052f, 45);		d.translate(t);		CHECK(d[0] == a+t);		CHECK(d[1] == b+t);		CHECK(d[2] == c+t);	}	TEST(BoundingBox)	{		// Dreieck nur in X-Y Ebene		Vector3D a(0,0,1), b(5,0,1), c(5,5,1);		Triangle d(a, b, c);		Cube cube = d.getBoundingBox();		CHECK(cube[0] == Vector3D(0,5,1));		CHECK(cube[1] == Vector3D(5,5,1));		CHECK(cube[2] == Vector3D(5,0,1));		CHECK(cube[3] == Vector3D(0,0,1));		CHECK(cube[4] == Vector3D(0,5,1));		CHECK(cube[5] == Vector3D(5,5,1));		CHECK(cube[6] == Vector3D(5,0,1));		CHECK(cube[7] == Vector3D(0,0,1));		// Dreieck im Raum		Vector3D a2(0,1,2), b2(3,4,5), c2(0,0,0);		Triangle d2(a2, b2, c2);		Cube box = d2.getBoundingBox();		CHECK(box[0] == Vector3D(0,4,5));		CHECK(box[1] == Vector3D(3,4,5));		CHECK(box[2] == Vector3D(3,0,5));		CHECK(box[3] == Vector3D(0,0,5));		CHECK(box[4] == Vector3D(0,4,0));		CHECK(box[5] == Vector3D(3,4,0));		CHECK(box[6] == Vector3D(3,0,0));		CHECK(box[7] == Vector3D(0,0,0));	}	TEST(RayIntersection)	{		Vector3D a(0,0,0), b(5,0,0), c(5,5,0);		Triangle d(a, b, c);				Ray r = {Vector3D(-1, 0, 0), Vector3D(1,0.3f,0)};		Vector3D res;		//CHECK(d.intersectsRay(r, &res));		//cout << res.x() << ", " << res.y() << ", " << res.z() << std::endl;	}	TEST(CubeIntersection)	{		Vector3D a(0,0,0), b(5,0,0), c(5,5,0);		Triangle d(a, b, c);		//Cube  	}}